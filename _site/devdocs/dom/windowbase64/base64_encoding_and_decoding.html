<h1>WindowBase64.Base64 encoding and decoding</h1><p><strong>Base64</strong> is a group of similar <a href="https://en.wikipedia.org/wiki/Binary-to-text_encoding">binary-to-text encoding</a> schemes that represent binary data in an ASCII string format by translating it into a radix-64 representation. The term <em>Base64</em> originates from a specific <a href="https://en.wikipedia.org/wiki/MIME#Content-Transfer-Encoding">MIME content transfer encoding</a>.</p> <p>Base64 encoding schemes are commonly used when there is a need to encode binary data that needs to be stored and transferred over media that are designed to deal with textual data. This is to ensure that the data remain intact without modification during transport. Base64 is commonly used in a number of applications including email via <a href="https://en.wikipedia.org/wiki/MIME">MIME</a>, and storing complex data in <a href="https://developer.mozilla.org/en-US/docs/XML">XML</a>.</p> <p>In JavaScript there are two functions respectively for decoding and encoding <em>base64</em> strings:</p> <ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/atob"><code>atob()</code></a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa"><code>btoa()</code></a></li> </ul> <p>The <code>atob()</code> function decodes a string of data which has been encoded using base-64 encoding. Conversely, the <code>btoa()</code> function creates a base-64 encoded ASCII string from a "string" of binary data.</p> <p>Both <code>atob()</code> and <code>btoa()</code> work on strings. If you want to work on <a href="https://developer.mozilla.org/en-US/docs/Web/API/ArrayBuffer"><code>ArrayBuffers</code></a>, please, read <a href="#Solution_2_%E2%80%93_rewrite_the_DOMs_atob()_and_btoa()_using_JavaScript's_TypedArrays_and_UTF-8">this paragraph</a>.</p> <div class="_table"><table class="topicpage-table"> <tbody> <tr> <td> <h2 class="Documentation" id="Documentation" name="Documentation">Documentation</h2> <dl> <dt><a href="https://developer.mozilla.org/en-US/docs/data_URIs"><code>data</code> URIs</a></dt> <dd><small><code>data</code> URIs, defined by <a href="http://tools.ietf.org/html/rfc2397">RFC 2397</a>, allow content creators to embed small files inline in documents.</small></dd> <dt><a href="https://en.wikipedia.org/wiki/Base64">Base64</a></dt> <dd><small>Wikipedia article about Base64 encoding.</small></dd> <dt><a href="https://html.spec.whatwg.org/multipage/webappapis.html#windoworworkerglobalscope-mixin">WindowOrWorkerGlobalScope mixin</a></dt> <dd>Specifies the <code>atob</code> and <code>btoa</code> methods and states that they encode to base64 as specified by <a href="https://tools.ietf.org/html/rfc4648">RFC 4648</a>.</dd> <dt><a href="https://tools.ietf.org/html/rfc4648">RFC 4648</a></dt> <dd>Specifies the base64 algorithm in section 4, and also defines an alternate base64url algorithm for URLs in section 5 (which is not the one used by <code>atob</code>/<code>btoa</code>).</dd> <dt><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/atob"><code>atob()</code></a></dt> <dd><small>Decodes a string of data which has been encoded using base-64 encoding.</small></dd> <dt><a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/btoa"><code>btoa()</code></a></dt> <dd><small>Creates a base-64 encoded ASCII string from a "string" of binary data.</small></dd> <dt><a href="#The_Unicode_Problem">The "Unicode Problem"</a></dt> <dd><small>In most browsers, calling <code>btoa()</code> on a Unicode string will cause a <code>Character Out Of Range</code> exception. This paragraph shows some solutions.</small></dd> <dt><a href="https://developer.mozilla.org/en-US/docs/URIScheme">URIScheme</a></dt> <dd><small>List of Mozilla supported URI schemes</small></dd> <dt><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/StringView"><code>StringView</code></a></dt> <dd>In this article is published a library of ours whose aims are: <ul> <li>creating a <a href="http://en.wikipedia.org/wiki/C_%28programming_language%29">C</a>-like interface for strings (i.e. array of characters codes —<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/ArrayBufferView"> <code>ArrayBufferView</code></a> in JavaScript) based upon the JavaScript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/ArrayBuffer"><code>ArrayBuffer</code></a> interface,</li> <li>creating a collection of methods for such string-like objects (since now: <code>stringView</code>s) which work <strong>strictly on array of numbers</strong> rather than on immutable JavaScript strings,</li> <li>working with other Unicode encodings, different from default JavaScript's UTF-16 <a href="../domstring"><code>DOMString</code></a>s,</li> </ul> </dd> </dl> <p><span class="alllinks"><a href="https://developer.mozilla.org/en-US/docs/tag/Base64">View All...</a></span></p> </td> <td> <h2 class="Tools" id="Tools" name="Tools">Tools</h2> <ul> <li><a href="#Solution_2_%E2%80%93_rewrite_the_DOMs_atob()_and_btoa()_using_JavaScript's_TypedArrays_and_UTF-8">Rewriting <code>atob()</code> and <code>btoa()</code> using <code>TypedArray</code>s and UTF-8</a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/StringView"><code>StringView</code> – a C-like representation of strings based on typed arrays</a></li> </ul> <p><span class="alllinks"><a href="https://developer.mozilla.org/en-US/docs/tag/Base64">View All...</a></span></p> <h2 class="Related_Topics" id="Related_Topics" name="Related_Topics">Related Topics</h2> <ul> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/ArrayBuffer"><code>ArrayBuffer</code></a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays">Typed arrays</a></li> <li><code><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/ArrayBufferView">ArrayBufferView</a></code></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/Uint8Array"><code>Uint8Array</code></a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays/StringView"><code>StringView</code> – a C-like representation of strings based on typed arrays</a></li> <li><a href="../domstring"><code>DOMString</code></a></li> <li><a href="https://developer.mozilla.org/en-US/docs/URI"><code>URI</code></a></li> <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURI"><code>encodeURI()</code></a></li> </ul> </td> </tr> </tbody> </table></div> <h2 id="The_Unicode_Problem">The "Unicode Problem"</h2> <p>Since <a href="../domstring"><code>DOMString</code></a>s are 16-bit-encoded strings, in most browsers calling <code>window.btoa</code> on a Unicode string will cause a <code>Character Out Of Range</code> exception if a character exceeds the range of a 8-bit byte (0x00~0xFF). There are two possible methods to solve this problem:</p> <ul> <li>the first one is to escape the whole string (with UTF-8, see <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent"><code>encodeURIComponent</code></a>) and then encode it;</li> <li>the second one is to convert the UTF-16 <a href="../domstring"><code>DOMString</code></a> to an UTF-8 array of characters and then encode it.</li> </ul> <p>Here is the prefered method along with two other "possible" methods.</p> <h3 id="Solution_1_–UTF-16_&gt;_binary_UTF8-in-16">Solution #1 –UTF-16 =&gt; binary UTF8-in-16</h3> <p>The fastest, most widely useable, most standard, and most future-ready way to solve the unicode problem is by transforming the UTF16 into UTF8-in-16 then use <code>btoa</code> on the UTF8-in-16 string. To understand this deeper, UTF16 uses 16 bits as the smallest unit of measure whereas UTF8 uses 8 bits as the smallest unit of measure. This means that the smallest a UTF16 character can be is 16 bits (2 bytes) meanwhile the smallest a UTF8 character can be is 8 bits (1 byte). Then, UTF8-in-16 is making the string encoded as UTF-8, but storing it as a UTF-16 string by only using 8 (from UTF8) of the 16 bits in each unit of measure of a UTF-16 string. This method is incredibly efficient because all it takes is a single simple super fast <code>String.prototype.replace</code> to convert between UTF-16 and UTF8-in-16. There is no need to encode the string as an array buffer then reencode it as a string. Rather, the below code simply and straightforwardly converts it in a single <code>String.prototype.replace</code>.</p> <pre data-language="js">(function(window){
    "use strict";
    var log = Math.log;
    var LN2 = Math.LN2;
    var clz32 = Math.clz32 || function(x) {return 31 - log(x &gt;&gt;&gt; 0) / LN2 | 0};
    var fromCharCode = String.fromCharCode;
    var originalAtob = atob;
    var originalBtoa = btoa;
    function btoaReplacer(nonAsciiChars){
        // make the UTF string into a binary UTF-8 encoded string
        var point = nonAsciiChars.charCodeAt(0);
        if (point &gt;= 0xD800 &amp;&amp; point &lt;= 0xDBFF) {
            var nextcode = nonAsciiChars.charCodeAt(1);
            if (nextcode !== nextcode) // NaN because string is 1 code point long
                return fromCharCode(0xef/*11101111*/, 0xbf/*10111111*/, 0xbd/*10111101*/);
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            if (nextcode &gt;= 0xDC00 &amp;&amp; nextcode &lt;= 0xDFFF) {
                point = (point - 0xD800) * 0x400 + nextcode - 0xDC00 + 0x10000;
                if (point &gt; 0xffff)
                    return fromCharCode(
                        (0x1e/*0b11110*/&lt;&lt;3) | (point&gt;&gt;&gt;18),
                        (0x2/*0b10*/&lt;&lt;6) | ((point&gt;&gt;&gt;12)&amp;0x3f/*0b00111111*/),
                        (0x2/*0b10*/&lt;&lt;6) | ((point&gt;&gt;&gt;6)&amp;0x3f/*0b00111111*/),
                        (0x2/*0b10*/&lt;&lt;6) | (point&amp;0x3f/*0b00111111*/)
                    );
            } else return fromCharCode(0xef, 0xbf, 0xbd);
        }
        if (point &lt;= 0x007f) return inputString;
        else if (point &lt;= 0x07ff) {
            return fromCharCode((0x6&lt;&lt;5)|(point&gt;&gt;&gt;6), (0x2&lt;&lt;6)|(point&amp;0x3f));
        } else return fromCharCode(
            (0xe/*0b1110*/&lt;&lt;4) | (point&gt;&gt;&gt;12),
            (0x2/*0b10*/&lt;&lt;6) | ((point&gt;&gt;&gt;6)&amp;0x3f/*0b00111111*/),
            (0x2/*0b10*/&lt;&lt;6) | (point&amp;0x3f/*0b00111111*/)
        );
    }
    window["btoaUTF8"] = function(inputString, BOMit){
        return originalBtoa((BOMit ? "\xEF\xBB\xBF" : "") + inputString.replace(
            /[\x80-\uD7ff\uDC00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]?/g, btoaReplacer
        ));
    }
    //////////////////////////////////////////////////////////////////////////////////////
    function atobReplacer(encoded){
        var codePoint = encoded.charCodeAt(0) &lt;&lt; 24;
        var leadingOnes = clz32(~codePoint);
        var endPos = 0, stringLen = encoded.length;
        var result = "";
        if (leadingOnes &lt; 5 &amp;&amp; stringLen &gt;= leadingOnes) {
            codePoint = (codePoint&lt;&lt;leadingOnes)&gt;&gt;&gt;(24+leadingOnes);
            for (endPos = 1; endPos &lt; leadingOnes; ++endPos)
                codePoint = (codePoint&lt;&lt;6) | (encoded.charCodeAt(endPos)&amp;0x3f/*0b00111111*/);
            if (codePoint &lt;= 0xFFFF) { // BMP code point
            result += fromCharCode(codePoint);
            } else if (codePoint &lt;= 0x10FFFF) {
            // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
            codePoint -= 0x10000;
            result += fromCharCode(
                (codePoint &gt;&gt; 10) + 0xD800,  // highSurrogate
                (codePoint &amp; 0x3ff) + 0xDC00 // lowSurrogate
            );
            } else endPos = 0; // to fill it in with INVALIDs
        }
        for (; endPos &lt; stringLen; ++endPos) result += "\ufffd"; // replacement character
        return result;
    }
    window["atobUTF8"] = function(inputString, keepBOM){
        if (!keepBOM &amp;&amp; inputString.substring(0,3) === "\xEF\xBB\xBF")
            inputString = inputString.substring(3); // eradicate UTF-8 BOM
        // 0xc0 =&gt; 0b11000000; 0xff =&gt; 0b11111111; 0xc0-0xff =&gt; 0b11xxxxxx
        // 0x80 =&gt; 0b10000000; 0xbf =&gt; 0b10111111; 0x80-0xbf =&gt; 0b10xxxxxx
        return originalAtob(inputString).replace(/[\xc0-\xff][\x80-\xbf]*/g, atobReplacer);
    };
})(typeof global == "" + void 0 ? typeof self == "" + void 0 ? this : self : global);</pre> <p>This solution may look scary big, but no need to worry too much: after minification, the uncompressed raw file is <a href="https://github.com/anonyco/BestBase64EncoderDecoder/blob/master/atobAndBtoaTogether.min.js">scarcely over a kilobyte in size</a>. This solution is very standard and very widely applicable because it can be used to encode high code point characters in a way that the browser can understand it as seen on the demo page <a href="https://anonyco.github.io/BestBase64EncoderDecoder/demo.html">here</a>. The full github repository is <a href="https://github.com/anonyco/BestBase64EncoderDecoder">AnonyCo's BestBase64EncoderDecoder</a>.</p>  <h3 id="Solution_2_–_escaping_the_string_before_encoding_it">Solution #2 – escaping the string before encoding it</h3> <pre data-language="js">function b64EncodeUnicode(str) {
    // first we use encodeURIComponent to get percent-encoded UTF-8,
    // then we convert the percent encodings into raw bytes which
    // can be fed into btoa.
    return btoa(encodeURIComponent(str).replace(/%([0-9A-F]{2})/g,
        function toSolidBytes(match, p1) {
            return String.fromCharCode('0x' + p1);
    }));
}

b64EncodeUnicode('✓ à la mode'); // "4pyTIMOgIGxhIG1vZGU="
b64EncodeUnicode('\n'); // "Cg=="
</pre> <p>To decode the Base64-encoded value back into a String:</p> <pre data-language="js">function b64DecodeUnicode(str) {
    // Going backwards: from bytestream, to percent-encoding, to original string.
    return decodeURIComponent(atob(str).split('').map(function(c) {
        return '%' + ('00' + c.charCodeAt(0).toString(16)).slice(-2);
    }).join(''));
}

b64DecodeUnicode('4pyTIMOgIGxhIG1vZGU='); // "✓ à la mode"
b64DecodeUnicode('Cg=='); // "\n"
</pre> <p><a href="https://git.daplie.com/Daplie/unibabel-js">Unibabel</a> implements common conversions using this strategy.</p> <h3 id="Solution_3_–_rewrite_the_DOMs_atob()_and_btoa()_using_JavaScript's_TypedArrays_and_UTF-8">Solution #3 – rewrite the DOMs <code>atob()</code> and <code>btoa()</code> using JavaScript's <code>TypedArray</code>s and UTF-8</h3> <p>Use a <a href="../textencoder">TextEncoder</a> polyfill such as <a href="https://github.com/inexorabletash/text-encoding">TextEncoding</a> (also includes legacy windows, mac, and ISO encodings), <a href="https://github.com/coolaj86/TextEncoderLite">TextEncoderLite</a>, combined with a <a href="https://github.com/feross/buffer">Buffer</a> and a Base64 implementation such as <a href="https://github.com/beatgammit/base64-js">base64-js</a>.</p> <p>When a native <code>TextEncoder</code> implementation is not available, the most light-weight solution would be to use <a href="https://github.com/coolaj86/TextEncoderLite">TextEncoderLite</a> with <a href="https://github.com/beatgammit/base64-js">base64-js</a>. Use the browser implementation when you can.</p> <p>The following function implements such a strategy. It assumes base64-js imported as <code>&lt;script type="text/javascript" src="base64js.min.js"/&gt;</code>. Note that TextEncoderLite only works with UTF-8.</p> <pre data-language="js">function Base64Encode(str, encoding = 'utf-8') {
    var bytes = new (TextEncoder || TextEncoderLite)(encoding).encode(str);        
    return base64js.fromByteArray(bytes);
}

function Base64Decode(str, encoding = 'utf-8') {
    var bytes = base64js.toByteArray(str);
    return new (TextDecoder || TextDecoderLite)(encoding).decode(bytes);
}
</pre> <p>In some cases, the above conversion to UTF-8 and then to Base64 will not be very space efficient. UTF-8 produces longer output than UTF-16 when the text contains a large percentage of characters in the range U+0800-U+FFFF, which are encoded with three bytes in UTF-8 but two in UTF-16. In the case where the JavaScript string contains evenly-distributed UTF-16 code points, one might consider encoding to UTF-16 instead of UTF-8 before the conversion to Base64, for a 40% reduction in size.</p><div class="_attribution">
  <p class="_attribution-p">
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding$edit" class="_attribution-link">Edit this page on MDN</a>
  </p>
</div>
<div class="_attribution">
  <p class="_attribution-p">
    &copy; 2005&ndash;2018 Mozilla Developer Network and individual contributors.<br>Licensed under the Creative Commons Attribution-ShareAlike License v2.5 or later.<br>
    <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding" class="_attribution-link">https://developer.mozilla.org/en-US/docs/Web/API/WindowBase64/Base64_encoding_and_decoding</a>
  </p>
</div>
